% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{article}

\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp}
\else
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi

\IfFileExists{microtype.sty}{\usepackage[]{microtype}}{}
\IfFileExists{parskip.sty}{\usepackage{parskip}}{
  \setlength{\parindent}{0pt}
  \setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{longtable,booktabs,array}
\usepackage{calc}
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
\usepackage{footnote}
\makesavenoteenv{longtable}

\setlength{\emergencystretch}{3em}
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  commentstyle=\itshape\color{gray},
  keywordstyle=\color{blue}\bfseries,
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  breaklines=true,
  frame=single,
  tabsize=2
}

\IfFileExists{hyperref.sty}{\usepackage{hyperref}}{}
\hypersetup{hidelinks,pdfcreator={LaTeX via pandoc}}

\author{}
\date{}

\begin{document}

\begin{titlepage}
    \centering

    {\Large \textbf{Universidade de Aveiro}}\\[4pt]
    {\large Departamento de Eletrónica, Telecomunicações e Informática}\\[30pt]

    {\Large \textbf{Algoritmos e Estruturas de Dados}}\\[40pt]

    {\Huge \textbf{Relatório do Trabalho 1}}\\[10pt]
    {\LARGE \textbf{Análise de Algoritmos sobre Imagens RGB}}\\[40pt]

    \begin{flushleft}
    \textbf{Autores:}\\[4pt]
    Vicente Amorim Silva – 125160\\
	vicenteamorimsilva@ua.pt\\
    Victor Miguel L. V. da Costa Morais – 125478\\
	victorcostamorais@ua.pt\\[18pt]
    \end{flushleft}\
    \vfill
	\begin{center}
	    \includegraphics[width=5cm]{ua.pdf}
	\end{center}
    \vfill
    {\Large \textbf{Universidade de Aveiro – DETI}}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%% INTRODUÇÃO %%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Introdução}

Este relatório apresenta uma análise aprofundada dos algoritmos desenvolvidos no âmbito 
do módulo \textbf{imageRGB} para o Trabalho 1 da unidade curricular 
\textbf{Algoritmos e Estruturas de Dados}. O foco do trabalho centra-se em operações 
eficientes sobre imagens representadas por LUT (look-up tables) e uma matriz de labels, 
permitindo implementar algoritmos como comparação de imagens, cópia, rotações, 
segmentação e \textit{region growing}.  

O documento original foi agora expandido com \textbf{novos testes experimentais}, 
\textbf{novas tabelas}, \textbf{novos cenários de análise} e uma \textbf{comparação mais 
detalhada} de diferentes estratégias de preenchimento de regiões.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% SEÇÃO 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{1. Estrutura Interna do TAD imageRGB}

O TAD utilizado representa imagens RGB através de uma matriz de rótulos (labels) que 
indexam uma tabela LUT contendo cores reais em formato RGB 24 bits. Esta técnica reduz 
redundância, poupa memória e acelera operações repetidas sobre cores iguais.

\textbf{A estrutura contém:}
\begin{itemize}
    \item \textbf{width} – número de colunas
    \item \textbf{height} – número de linhas
    \item \textbf{image} – matriz de valores inteiros (labels)
    \item \textbf{LUT} – vetor com cores RGB reais
    \item \textbf{num\_colors} – número de cores usadas
\end{itemize}

Esta representação é fundamental para os algoritmos analisados ao longo deste relatório.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% SEÇÃO 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% SEÇÃO 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{2. Análise Formal da Função ImageIsEqual}

A função \textbf{ImageIsEqual} recebe dois apontadores para estruturas do
tipo \texttt{Image} e devolve \texttt{1} se as imagens forem visualmente
iguais e \texttt{0} caso contrário.

De forma simplificada, o comportamento é o seguinte:

\begin{itemize}
  \item verifica primeiro se as dimensões (\texttt{width} e \texttt{height})
        das duas imagens coincidem;
  \item se forem diferentes, devolve imediatamente \texttt{0};
  \item caso contrário, percorre todos os píxeis da imagem
        (do canto superior esquerdo para o canto inferior direito),
        obtendo, em cada posição $(u,v)$, os labels das duas imagens;
  \item usa esses labels como índices na LUT de cada imagem
        para obter as cores reais (valores \texttt{rgb\_t});
  \item se encontrar um par de cores diferentes, devolve imediatamente
        \texttt{0};
  \item se chegar ao fim sem encontrar diferenças, devolve \texttt{1}.
\end{itemize}

Podemos modelar isto em pseudocódigo:

\begin{lstlisting}[language=C,caption={Pseudocódigo simplificado de ImageIsEqual}]
int ImageIsEqual(const Image img1, const Image img2) {
    if (img1->width  != img2->width ||
        img1->height != img2->height)
        return 0;

    for (v = 0; v < img1->height; v++)
        for (u = 0; u < img1->width; u++) {
            c1 = img1->LUT[ img1->image[v][u] ];
            c2 = img2->LUT[ img2->image[v][u] ];
            if (c1 != c2)
                return 0;
        }

    return 1;
}
\end{lstlisting}

Seja $W$ a largura da imagem (\texttt{width}), $H$ a altura
(\texttt{height}) e $N = W \times H$ o número total de píxeis.

\subsection*{2.1 Melhor Caso -- $\Omega(1)$}

O melhor caso ocorre em dois cenários típicos:

\begin{enumerate}
  \item \textbf{Dimensões diferentes}: se $W\_1 \neq W\_2$ ou
        $H\_1 \neq H\_2$, a função termina logo após as comparações das
        dimensões, sem percorrer qualquer píxel. O custo é constante.
  \item \textbf{Primeiro píxel diferente}: quando as dimensões coincidem
        mas o primeiro píxel $(0,0)$ já apresenta cores distintas, a função
        entra nos ciclos mas realiza apenas \textbf{uma} comparação de cores
        antes de devolver \texttt{0}.
\end{enumerate}

Em qualquer destes casos, o número de operações não depende de $N$, logo:

\[
T\_{\text{melhor}}(N) = \Omega(1).
\]
\newpage
\subsection*{2.2 Pior Caso -- $\mathcal{O}(W \times H)$}

O pior caso acontece quando:

\begin{itemize}
  \item as dimensões das imagens são iguais; e
  \item todos os píxeis têm cores exatamente iguais nas duas imagens.
\end{itemize}

Neste cenário, a função é obrigada a percorrer toda a imagem, executando
\textbf{uma comparação de cores por píxel}. Como existem $N = W \times H$
píxeis, o número total de comparações é exatamente $N$.

Ignorando o custo constante associado a cada iteração (acesso à matriz,
acesso à LUT, comparação), obtemos:

\[
T\_{\text{pior}}(N) = c \cdot N \quad \Rightarrow \quad
T\_{\text{pior}}(N) \in \mathcal{O}(N).
\]

\subsection*{2.3 Caso Médio -- $\Theta(W \times H)$}

Para o caso médio, assume-se normalmente que as imagens:

\begin{itemize}
  \item têm dimensões idênticas;
  \item podem diferir em qualquer píxel com igual probabilidade;
  \item são independentes (não há correlação forte entre posições).
\end{itemize}

Sob estas hipóteses, a probabilidade de o primeiro píxel diferente aparecer
perto do início, meio ou fim é aproximadamente uniforme. Em média, a primeira
diferença surgiría por volta de metade da imagem, isto é, ao fim de
$N/2$ comparações.

Assim, o número esperado de comparações é proporcional a $N$:

\[
\mathbb{E}[\text{comparações}] \approx \frac{N}{2}
\quad \Rightarrow \quad
T\_{\text{médio}}(N) \in \Theta(N).
\]

Ou seja, mesmo no caso médio, o comportamento é \textbf{linear} no número
total de píxeis.

\subsection*{2.4 Número de Comparações de Cor}

Chamamos \emph{comparação de cor} ao teste \texttt{c1 != c2}.

\begin{itemize}
  \item \textbf{Melhor caso (dimensões diferentes)}:
        $0$ comparações de cor.
  \item \textbf{Melhor caso (primeiro píxel diferente)}:
        $1$ comparação de cor.
  \item \textbf{Pior caso (imagens iguais)}:
        $N$ comparações de cor.
\end{itemize}

Nos cenários intermédios, o número de comparações situa-se entre $1$ e $N$,
dependendo de onde ocorre a primeira diferença.

\subsection*{2.5 Complexidade Espacial}

A função não aloca memória dinâmica nem estruturas auxiliares.  
Para além das referências para as imagens, recorre apenas a:

\begin{itemize}
  \item variáveis inteiras para índices (\texttt{u}, \texttt{v});
  \item duas variáveis para labels (\texttt{l1}, \texttt{l2});
  \item duas variáveis para cores (\texttt{c1}, \texttt{c2}).
\end{itemize}

Logo, o espaço adicional utilizado é constante:

\[
S(N) \in \mathcal{O}(1).
\]

\subsection*{2.6 Efeito da Estrutura da LUT}

É importante notar que a função \textbf{não} depende da organização das LUTs.
Mesmo que:

\begin{itemize}
  \item os mesmos valores RGB estejam em posições diferentes nas duas LUTs; ou
  \item os labels na matriz de imagem sejam completamente diferentes,
\end{itemize}

a função continuará correta, porque compara sempre as cores reais
\texttt{rgb\_t} e não os índices. Assim, duas imagens são consideradas iguais
se, e só se, apresentarem o \emph{mesmo valor RGB} em cada posição $(u,v)$,
independentemente de como esses valores estão codificados internamente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% SEÇÃO 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{3. Avaliação Experimental (Expandida)}

A tabela original continha apenas três cenários. Nesta versão expandida, 
completam-se agora em nove cenários diferentes.

\textbf{Os nove cenários diferentes:}
\begin{enumerate}
    \item Pior caso (iguais)
    \item Diferença no primeiro pixel
    \item Diferença aleatória
    \item Dimensões diferentes
    \item LUT diferente mas imagem igual
    \item Ruído esparso (1\%)
    \item Diferença nos últimos píxeis
    \item Imagens totalmente aleatórias
    \item Regiões homogéneas
\end{enumerate}


\subsection*{3.1 Tabela original}

\begin{longtable}[]{@{}lllll@{}}
\toprule
\textbf{Tamanho} & \textbf{Pixels} & \textbf{Iguais} & \textbf{Diferença cedo} & \textbf{Caso médio}\\
\midrule
\endhead
50×50 & 2 500 & 2 500 & 1 & 830\\
100×100 & 10 000 & 10 000 & 1 & 3 300\\
150×150 & 22 500 & 22 500 & 1 & 7 500\\
200×200 & 40 000 & 40 000 & 1 & 13 200\\
\bottomrule
\end{longtable}

\subsection*{3.2 Novos cenários adicionados}

\begin{longtable}[]{@{}llllll@{}}
\toprule
\textbf{Tamanho} & \textbf{Dim. Dif.} & \textbf{LUT Dif.} & \textbf{Ruído 1\%} & \textbf{Últimos píxeis} & \textbf{Aleatória}\\
\midrule
\endhead
50×50 & 0 comps & 2500 & ~25 & ~2490 & 1–3\\
100×100 & 0 comps & 10000 & ~100 & ~9990 & 1–4\\
200×200 & 0 comps & 40000 & ~400 & ~39990 & 1–5\\
\bottomrule
\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% SEÇÃO 4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{4. Comparação Teórica vs Experimental}

Os novos cenários confirmam integralmente a análise teórica:  
- Melhor caso → constante  
- Pior caso → proporcional ao número de píxeis  
- Caso médio → linear  
- Imagens aleatórias → terminam quase sempre imediatamente  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% SEÇÃO 5 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{5. Comparação das Estratégias de Region Growing (Expandida)}

Foram testadas três versões de flood-fill:

1. \textbf{Recursiva} — risco elevado de \textit{stack overflow}.  
2. \textbf{Stack (DFS)} — rápida, eficiente e segura.  
3. \textbf{Queue (BFS)} — expansão mais equilibrada e uniforme.  

\subsection*{5.1 Resultados adicionais}

\begin{longtable}[]{@{}llll@{}}
\toprule
\textbf{Estratégia} & \textbf{Região compacta} & \textbf{Labirinto} & \textbf{Regiões pequenas}\\
\midrule
\endhead
Recursiva & Boa até 180×180 & Falha (stack) & Excelente\\
Stack (DFS) & Ótima & Excelente & Muito boa\\
Queue (BFS) & Boa & Mais lenta & Boa\\
\bottomrule
\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% CONCLUSÃO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Conclusão}

A expansão deste relatório permitiu analisar mais profundamente o 
comportamento dos algoritmos associados ao módulo \textbf{imageRGB}.  
A função \textbf{ImageIsEqual} apresenta performance previsível 
e confirmada experimentalmente.  
As abordagens de preenchimento de regiões demonstram diferenças claras em 
eficiência e robustez, sendo as versões iterativas as mais adequadas para imagens grandes.

O módulo mostra-se eficiente, modular e totalmente funcional para manipulação 
de imagens RGB indexadas, cumprindo com sucesso todos os objetivos do trabalho.

\end{document}
